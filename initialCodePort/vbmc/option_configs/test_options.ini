[Options]
# Explicit noise handling'
UncertaintyHandling = []
# Array with indices of integer variables'
IntegerVars = []
# Display
display = "iter"
# Base observation noise magnitude (standard deviation)'
NoiseSize = []
# Max number of consecutive repeated measurements for noisy inputs'
MaxRepeatedObservations = 0
# Multiplicative discount True acquisition fcn
# to repeat measurement at the same location'
RepeatedAcqDiscount = 1
# Number of initial target fcn evals'
FunEvalStart = np.maximum(D, 10)
# Base step size for stochastic gradient descent'
SGDStepSize = 0.005
# Skip active sampling the first iteration after warmup'
SkipActiveSamplingAfterWarmup = False
# Use ranking criterion to pick best non-converged solution'
RankCriterion = True
# Required stable iterations to switch entropy approximation'
TolStableEntropyIters = 6
# Use variable component means for variational posterior'
VariableMeans = True
# Use variable mixture weight for variational posterior'
VariableWeights = True
# Penalty multiplier for small mixture weights'
WeightPenalty = 0.1
# Run in diagnostics mode get additional info'
Diagnostics = False
# Output function'
OutputFcn = []
# Fraction of allowed exceptions when computing iteration stability'
TolStableExcptFrac = 0.2
# Evaluated fcn values at X0'
Fvals = []
# Use Optimization Toolbox (if empty determine at runtime)'
OptimToolbox = []
# Weighted proposal fcn for uncertainty search'
ProposalFcn = []
# Automatic nonlinear rescaling of variables'
NonlinearScaling = True
# Fast search acquisition fcn(s)'
SearchAcqFcn = "@acqf_vbmc"
# Samples for fast acquisition fcn eval per new point'
NSsearch = 2 ** 13
# Total samples for preliminary Monte Carlo approx. of the entropy'
NSentFast = 0